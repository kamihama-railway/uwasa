# Uwasa 技术规格与深度分析文档

本文档提供 Uwasa 引擎的详细技术说明，包括表达式类型、返回值规范、优化等级底层逻辑及使用指南。

## 1. 表达式种类与返回值分析

Uwasa 引擎支持以下几类核心表达式，每种表达式在求值后都会返回特定的 Go 类型。

| 表达式类型 | 语法示例 | 预期返回值类型 | 说明 |
| :--- | :--- | :--- | :--- |
| **数值字面量** | `123`, `3.14` | `int64` 或 `float64` | 引擎自动区分整数与浮点数。不含小数点的解析为 `int64`。 |
| **字符串字面量** | `"hello"` | `string` | 必须使用双引号包裹。 |
| **布尔字面量** | `true`, `false` | `bool` | 区分大小写，全小写。 |
| **标识符** | `user_score` | `any` | 从 `Context` 中获取的原始类型。 |
| **前缀表达式** | `-a` | `int64` 或 `float64` | 仅支持负号 `-`。类型与操作数一致。 |
| **算术中缀表达式** | `a + b`, `a * b` | `int64`, `float64`, `string` | 如果操作数均为 `int64` 则返回 `int64`；任一为浮点则提升为 `float64`；字符串加法返回 `string`。 |
| **比较中缀表达式** | `a > 10` | `bool` | 支持 `==`, `>`, `<`, `>=`, `<=`, `!=`。 |
| **逻辑中缀表达式** | `a && b`, `a \|\| b` | `bool` | 遵循短路求值逻辑。 |
| **条件表达式 (If)** | `if a is b else c` | `any` | 返回被选中的分支表达式求值结果。若为简单 `if a` 则返回 `bool`。 |
| **赋值表达式** | `a = 10` | `any` | 返回赋的值，同时产生修改 `Context` 的副作用。 |

---

## 2. 表达式返回值深度解析

在 Uwasa 引擎中，理解每个表达式的返回值及其来源对于编写复杂的规则至关重要。以下是详细的分类说明：

### 2.1 条件表达式 (If Expression)
条件表达式根据其结构不同，返回值来源也不同：

- **简单模式 (`if <cond>`)**:
    - **返回值**: `bool`
    - **来源**: 直接返回条件表达式 `<cond>` 的真值判定结果。通常用于规则过滤。
- **分支模式 (`if <cond> is <cons> else is <alt>`)**:
    - **返回值**: `any` (由选中的分支决定)
    - **来源**: 若 `<cond>` 为真，返回 `<cons>` 表达式的计算结果；否则返回 `<alt>` 表达式的结果。
    - **缺省行为**: 如果没有 `else` 分支且条件不满足，返回 `nil`。
- **动作模式 (`if <cond> then <action>`)**:
    - **返回值**: `any` 或 `nil`
    - **来源**: 若 `<cond>` 为真，执行并返回 `<action>` 的计算结果；若为假，**不执行**动作并直接返回 `nil`。

### 2.2 赋值表达式 (Assignment)
- **语法**: `name = expression`
- **返回值**: `any`
- **来源**: 返回右侧 `expression` 的求值结果。
- **副作用**: 将求得的值写入 `Context`。这意味着你可以进行链式赋值，如 `a = b = 10`（此时 `a` 和 `b` 都被设为 10，表达式最终返回 10）。

### 2.3 计算表达式 (Calculation/Arithmetic)
计算表达式的返回值遵循“数值提升”和“快速路径”原则：

- **纯整数计算**:
    - **条件**: 运算符两边均为 `int64` 类型。
    - **返回值**: `int64`
    - **来源**: 执行 Go 原生 64 位整数运算。
- **浮点/混合计算**:
    - **条件**: 任一操作数为 `float64`。
    - **返回值**: `float64`
    - **来源**: 引擎自动将另一操作数提升为 `float64` 后执行运算。
- **字符串拼接**:
    - **条件**: 使用 `+` 且两边均为 `string`。
    - **返回值**: `string`
    - **来源**: 两个字符串连接后的新字符串。

### 2.4 比较与逻辑表达式
- **比较 (`==`, `>`, `<`, 等)**: 始终返回 `bool`。
- **逻辑 (`&&`, `||`)**: 始终返回 `bool`。得益于短路逻辑，若左侧已能决定结果，右侧将不会被求值。

### 2.5 内置函数 (Built-in Functions)
- **`concat(arg1, arg2, ...)`**:
    - **返回值**: `string`
    - **说明**: 将所有参数转换为字符串并拼接。使用 `sync.Pool` 复用 Buffer 并在拼接前预计算总长度，是最高效的字符串处理方式。
    - **编译时优化**: 若参数均为常量，该函数将在编译阶段被折叠为单个字符串字面量。

---

## 3. 优化等级与底层逻辑

Uwasa 提供三级可选优化，通过 `EngineOptions` 进行配置。

### OptNone (不优化)
- **底层逻辑**: 直接对解析后的原始抽象语法树 (AST) 进行遍历求值。
- **适用场景**: 规则仅执行一次，或需要完全保留原始结构用于调试。

### OptBasic (基础优化 - 默认)
- **底层逻辑**:
    - **常量折叠 (Constant Folding)**: 在编译阶段计算所有字面量组成的子树。例如 `1 + 2 * 3` 在执行前就被替换为字面量 `7`。
    - **布尔短路折叠**: 处理带有变量的逻辑折叠。例如 `false && any_expr` 会被折叠为 `false`，从而在运行时完全跳过 `any_expr` 的执行。
- **性能提升**: 显著减少运行时的算术运算和条件分支判断。

### OptAggressive (激进优化)
- **底层逻辑**:
    - **代数简化 (Algebraic Simplification)**: 利用代数恒等式进一步压缩 AST。
        - `x + 0` -> `x`
        - `x * 1` -> `x`
        - `x * 0` -> `0`
        - `x - x` -> `0` (会先检查 `x` 是否包含副作用)
        - `x == x` -> `true`
    - **静态检查 (Static Analysis)**:
        - 检测常数除零错误。
        - 检测字面量类型不匹配（如 `"str" - 1`）。
- **性能提升**: 在包含大量变量偏移或冗余计算的复杂规则中，可进一步减少 AST 深度，提升执行速度。

---

## 3. 使用方式详述

### 基础使用 (默认 OptBasic)
```go
engine, err := uwasa.NewEngine(`score + 10 > 100`)
```

### 指定优化等级
```go
opts := uwasa.EngineOptions{
    OptimizationLevel: uwasa.OptAggressive,
}
engine, err := uwasa.NewEngineWithOptions(`(a + 0) * 1 + (b - b)`, opts)
// 经过 OptAggressive 后，AST 实际上简化为了标识符 `a` 的求值。
```

### 混合类型计算规范
引擎在执行时会尝试遵循以下“快速路径”以降低内存分配：
1. **纯整数路径**: 若操作数均为 `int64`，直接执行机器级整数运算。
2. **提升路径**: 若出现 `float64`，则将另一方提升后进行浮点运算。
3. **兼容路径**: 若输入为原生 `int` 或 `float32`，会先进行类型检测并装箱转换。*建议在 `vars` 中直接传入 `int64` 以获得极致性能。*

---

## 4. 静态错误报告

在 `OptAggressive` 模式下，引擎会返回更详细的编译时错误：
- `static analysis errors: [division by zero]`: 检测到硬编码的除以 0。
- `static analysis errors: [invalid operation: string - string/number]`: 检测到不合法的字符串数学运算。
