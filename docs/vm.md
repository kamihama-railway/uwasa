# Uwasa 虚拟机 (VM) 设计文档

## 概述
为了进一步提升运行时性能并减少内存分配，Uwasa 引入了基于字节码的虚拟机 (VM) 子引擎。该引擎通过将 AST 编译为线性指令流，并使用高效的栈式执行模型，减少了解释执行过程中的递归调用和接口装箱开销。

## 核心组件

### 1. 字节码编译器 (`vm_compiler.go`)
编译器负责将优化后的 AST 转换为 `Bytecode` 结构。它包含以下阶段：
- **遍历与发射**：递归遍历 AST 节点，生成原始操作码流。
- **渲染 (Rendering)**：将变长字节码转换为定长的指令结构 (`vmInstruction`)，并进行指令级优化。

### 2. 虚拟机执行器 (`vm.go`)
执行器是一个紧凑的栈式虚拟机。其特性包括：
- **无装箱数值**：使用自定义的 `Value` 结构体，通过原始位存储 `int64`、`float64` 和 `bool`，避免了 Go 接口 (`any`) 的分配开销。
- **静态栈分配**：在大多数情况下使用预分配的数组栈，消除执行过程中的堆分配。
- **变量预取与索引化**：在执行前根据索引一次性加载变量，减少执行过程中的 Map 查找。

## 指令优化

### 指令融合 (Instruction Fusion)
通过在渲染阶段识别常见的指令模式并将其替换为单一的高效指令，减少指令分发 (Dispatch) 的循环次数：
- **算术融合**：如 `OpAddGlobal` (变量 + 栈顶)、`OpAddConst` (常量 + 栈顶)。
- **逻辑融合**：如 `OpJumpIfFalsePop` (判断并弹出)。
- **深度融合**：如 `OpFusedCompareGlobalConstJumpIfFalse`，将变量读取、常量对比、跳转合并为一个操作，极大提升了 `if...is...else` 分支的性能。

## 性能表现
VM 模式在以下场景中具有显著优势：
1. **多变量计算**：通过变量索引化消除了频繁的字符串查找开销。
2. **深度分支逻辑**：指令融合使得条件判断几乎接近原生 Go 的执行速度。
3. **高频执行场景**：几乎零分配 (Zero Allocation) 的特性使得 VM 在并发高负载下表现更稳健。

## 使用方法
在创建引擎时开启 `UseVM` 选项：

```go
engine, _ := NewEngineWithOptions(input, EngineOptions{
    UseVM: true,
})
```
