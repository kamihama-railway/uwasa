# 开发技术手册 (Development Technical Manual)

本文档旨在介绍 Uwasa 引擎的核心技术实现细节、性能优化特性以及开发设计决策。

## 1. 核心架构

Uwasa 采用了典型的**编译器前端 + 树走访解释器**架构：

- **词法分析 (Lexing)**: 逐字符扫描，支持有限状态自动机风格的 Token 识别。
- **语法分析 (Parsing)**: 基于 **Pratt 解析算法** (Top Down Operator Precedence)。该算法相比传统的递归下降能更优雅地处理运算符优先级，代码结构扁平且易于维护。
- **抽象语法树 (AST)**: 所有的源码最终被编译成强类型的节点树（见 `ast.go`）。
- **求值引擎 (Evaluation)**: 通过对 AST 节点的深度优先遍历，结合上下文进行递归求值。

## 2. 关键技术特性

### 2.1 递归求值与逻辑分发
引擎的 `Eval` 函数是整个执行流程的核心。它利用 Go 的类型分支（Type Switch）实现求值分发：
- **逻辑单元**: 处理条件分支 (`IfExpression`)、逻辑运算 (`InfixExpression` 且操作符为 `&&`)。
- **计算单元**: 处理算术运算、赋值操作 (`AssignExpression`) 以及字面量。

### 2.2 短路求值 (Short-circuit Evaluation)
对于 `&&` 运算符，引擎实现了严格的短路逻辑。如果左侧表达式结果为“假”，则完全跳过右侧表达式的解析与执行。这不仅能提升性能，还能确保副作用（如赋值）在预期时才发生。

### 2.3 类型自动提升
引擎内部为了简化计算逻辑，将所有的数值类型（`int`, `int32`, `int64`, `float32`）统一提升为 `float64`。同时，`+` 操作符具备多态性，当左右操作数均为字符串时执行高效拼接。

## 3. 性能优化深度剖析

Uwasa 针对规则引擎通常处于“高频调用、低延迟”的场景，进行了以下深度优化：

### 3.1 对象池化 (Object Pooling)
通过 `sync.Pool` 实现了对 `Lexer`、`Parser` 以及 `MapContext` 的全面复用。
- **原理**: 每次执行不再分配新的解析器对象，而是从池中获取。
- **Reset 机制**: 对象在归还池之前会执行 `Reset` 操作，清除上一次执行留下的错误信息和状态，确保状态隔离的同时极大降低了 GC 压力。

### 3.2 零分配 Token 识别
在词法分析阶段，对于常见的中缀操作符（如 `==`, `>=`, `&&` 等），Lexer 直接返回预先定义的常量字符串，而非在堆上重新分配内存。

### 3.3 接口装箱优化 (Boxing Optimization)
在 Evaluator 内部，频繁返回的 `true` 和 `false` 布尔值被预先装箱为 `interface{}` 类型。这意味着执行逻辑表达式时，不再需要临时的装箱分配，直接返回常量指针。

### 3.4 快速优先级检索
Parser 放弃了传统的 `map` 查找操作符优先级，改为使用编译器更容易优化的 `switch` 语句，进一步压榨执行效率。

## 4. 线程安全性说明

- **Parser/Lexer**: 由于使用了对象池且在单次任务中非线程安全，引擎确保每个任务拥有独立的解析器实例。
- **Engine**: `Engine` 实例在解析完成后是**只读**的，因此多个协程可以安全地共享同一个 `Engine` 实例进行并发求值。
- **Context**: 内置的 `MapContext` 实例被设计为单次求值生命周期内使用，归还池时会自动解绑变量映射。

## 5. 易用性设计

- **接口化隔离**: 通过 `Context` 接口，用户可以灵活定制变量的存取逻辑。
- **友好的 Stringify**: 每个 AST 节点均实现了 `String()` 方法，方便开发者在调试时还原和审查生成的语法树结构。
