# 开发技术手册 (Development Technical Manual)

本文档旨在介绍 Uwasa 引擎的核心技术实现细节、性能优化特性以及开发设计决策。

## 1. 核心架构

Uwasa 采用了典型的**编译器前端 + 树走访解释器**架构：

- **词法分析 (Lexing)**: 逐字符扫描，支持有限状态自动机风格的 Token 识别。
- **语法分析 (Parsing)**: 基于 **Pratt 解析算法** (Top Down Operator Precedence)。该算法相比传统的递归下降能更优雅地处理运算符优先级，代码结构扁平且易于维护。
- **抽象语法树 (AST)**: 所有的源码最终被编译成强类型的节点树（见 `ast.go`）。
- **求值引擎 (Evaluation)**: 通过对 AST 节点的深度优先遍历，结合上下文进行递归求值。

## 2. 关键技术特性

### 2.1 递归求值与逻辑分发
引擎的 `Eval` 函数是整个执行流程的核心。它利用 Go 的类型分支（Type Switch）实现求值分发：
- **逻辑单元**: 处理条件分支 (`IfExpression`)、逻辑运算 (`InfixExpression` 且操作符为 `&&`)。
- **计算单元**: 处理算术运算、赋值操作 (`AssignExpression`) 以及字面量。

### 2.2 短路求值 (Short-circuit Evaluation)
对于 `&&` 运算符，引擎实现了严格的短路逻辑。如果左侧表达式结果为“假”，则完全跳过右侧表达式的解析与执行。这不仅能提升性能，还能确保副作用（如赋值）在预期时才发生。

### 2.3 数值双轨制与快速路径
为了兼顾通用性与性能，引擎采用了数值双轨制：
- **存储层**: `NumberLiteral` 同时支持 `int64` 和 `float64` 存储。
- **执行层 (Fast Path)**: `Evaluator` 包含专门的整数运算分支。若操作数均为整数，直接执行 CPU 原生指令，避免了昂贵的浮点数转换。
- **类型自动提升**: 仅在必要时（如 `int64 * float64`）执行自动提升为 `float64` 的逻辑。

### 2.4 内置函数系统 (Built-in Functions)
引擎支持通过 `CallExpression` 调用内置函数。
- **扩展性**: 函数注册在 `evaluator.go` 的 `builtins` 映射中。
- **高性能拼接**: `concat` 函数利用 `sync.Pool` 复用 `bytes.Buffer` 并预计算长度，实现了线性时间复杂度的字符串处理。

## 3. 性能优化深度剖析

Uwasa 针对规则引擎通常处于“高频调用、低延迟”的场景，进行了以下深度优化：

### 3.1 对象池化 (Object Pooling)
通过 `sync.Pool` 实现了对 `Lexer`、`Parser`、`MapContext` 以及 `bytes.Buffer` 的全面复用。
- **原理**: 每次执行不再分配新的解析器对象或缓冲区，而是从池中获取。
- **Reset 机制**: 对象在归还池之前会执行 `Reset` 操作，清除上一次执行留下的错误信息和状态，确保状态隔离的同时极大降低了 GC 压力。

### 3.2 零分配 Token 识别
在词法分析阶段，对于常见的中缀操作符（如 `==`, `>=`, `&&` 等），Lexer 直接返回预先定义的常量字符串，而非在堆上重新分配内存。

### 3.3 接口装箱优化 (Boxing Optimization)
在 Evaluator 内部，频繁返回的 `true` 和 `false` 布尔值被预先装箱为 `interface{}` 类型。这意味着执行逻辑表达式时，不再需要临时的装箱分配，直接返回常量指针。

### 3.4 快速优先级检索
Parser 放弃了传统的 `map` 查找操作符优先级，改为使用编译器更容易优化的 `switch` 语句。

### 3.5 分层编译优化 (Tiered Compilation Optimization)
Uwasa 引入了类似现代编译器的分层优化机制：
- **Level 1: 常量折叠 (Fold)**: 语法分析后的初步处理，消除所有确定性的字面量计算。
- **Level 2: 独立再编译 (Recompiler)**: 针对含变量表达式的代数简化，利用数学恒等式减少运行时节点数量，并伴随副作用感知检测。

## 4. 线程安全性说明

- **Parser/Lexer**: 由于使用了对象池且在单次任务中非线程安全，引擎确保每个任务拥有独立的解析器实例。
- **Engine**: `Engine` 实例在解析完成后是**只读**的，因此多个协程可以安全地共享同一个 `Engine` 实例进行并发求值。
- **Context**: 内置的 `MapContext` 实例被设计为单次求值生命周期内使用，归还池时会自动解绑变量映射。

## 5. 易用性设计

- **接口化隔离**: 通过 `Context` 接口，用户可以灵活定制变量的存取逻辑。
- **友好的 Stringify**: 每个 AST 节点均实现了 `String()` 方法，方便开发者在调试时还原和审查生成的语法树结构。
