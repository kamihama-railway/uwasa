# Uwasa 引擎设计文档

Uwasa 引擎是一个高性能、专用的规则引擎，旨在处理动态规则求值。它采用了经典的解释器架构，并针对内存和速度进行了深度优化。

## 架构概览

引擎的执行过程分为三个主要阶段：
1. **词法分析 (Lexer)**: 将源代码字符串切分为 Token。
2. **语法分析 (Parser)**: 将 Token 流转换为抽象语法树 (AST)。
3. **解释执行 (Evaluator)**: 遍历 AST 并根据给定的上下文 (Context) 计算结果。

---

## 实现单元详解

为了更好地理解内部逻辑，我们将实现划分为**逻辑单元**和**计算单元**。

### 1. 逻辑单元 (Logical Units)

逻辑单元负责程序的流程控制、条件判断和布尔逻辑。

- **条件分支 (IfExpression)**:
  - 支持 `if <cond> is <result> else is <result>` 模式。
  - 支持 `if <cond> then <action>` 模式（前置条件式）。
  - 支持 `if <cond>` 模式（简单判断，返回布尔值）。
  - 实现逻辑：首先求值 `Condition`，根据其真值 (Truthiness) 决定执行 `Consequence` 还是 `Alternative`。

- **布尔运算 (Boolean Logic)**:
  - **短路与 (&&)**: 实现了短路求值逻辑。如果左侧表达式为假，则立即返回 `false`，不再求值右侧表达式。这对于包含副作用（如赋值）的规则至关重要。

- **比较运算 (Comparisons)**:
  - 支持 `==`, `>`, `<`, `>=`, `<=`。
  - 实现逻辑：对于数值，统一转换为 `float64` 后进行比较；对于字符串和其他类型，支持相等的判定。

### 2. 计算单元 (Calculation Units)

计算单元负责数据的处理、数值运算和状态变更。

- **算术运算 (Arithmetic)**:
  - 支持加法 (`+`) 和减法 (`-`)。
  - **字符串拼接**: 加法运算符在作用于两个字符串时，会自动执行拼接操作。
  - **数值提升**: 自动将 `int`, `int32`, `int64`, `float32` 等类型提升为 `float64` 进行统一运算。

- **赋值操作 (Assignment)**:
  - 支持 `<ident> = <expr>`。
  - 赋值表达式不仅会更新上下文中的变量，还会返回被赋予的值。
  - 注意：在 `if...then` 结构中，赋值是常见的副作用操作。

---

## 性能优化实现

Uwasa 引擎针对高并发和高频率调用场景进行了多项优化：

1. **对象池化 (Object Pooling)**:
   - 使用 `sync.Pool` 复用 `Lexer`、`Parser` 和 `MapContext` 实例。
   - 大幅减少了在高并发下的临时内存分配 (Allocations) 和 GC 压力。

2. **零分配 Token 解析**:
   - Lexer 在解析常用操作符（如 `==`, `&&`）时，直接返回预定义的常量字符串，避免了不必要的字符串切片分配。

3. **类型装箱优化**:
   - 在 Evaluator 中，对常用的布尔返回值（`true`, `false`）使用预分配的 `interface{}` 对象，消除了布尔值装箱带来的开销。

4. **高效优先级解析**:
   - Parser 采用了 Pratt 解析算法，并使用 `switch` 语句优化了运算符优先级的查找过程，相比 Map 查找具有更高的执行效率。

---

## 扩展性设计

- **Context 接口**: 用户可以实现自定义的 `Context`，例如对接 Redis 或数据库，实现动态变量获取。
- **AST 节点**: 引擎的设计允许通过增加新的 Node 类型和对应的解析/求值逻辑来轻松扩展语言特性。
