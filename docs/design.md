# Uwasa 引擎设计文档

Uwasa 引擎是一个高性能、专用的规则引擎，旨在处理动态规则求值。它采用了经典的解释器架构，并针对内存和速度进行了深度优化。

## 架构概览

引擎的执行过程分为四个主要阶段：
1. **词法分析 (Lexer)**: 将源代码字符串切分为 Token。
2. **语法分析 (Parser)**: 将 Token 流转换为抽象语法树 (AST)。
3. **编译优化 (Optimizer/Recompiler)**: 对 AST 进行多轮变换，包括常量折叠和代数简化。
4. **解释执行 (Evaluator)**: 遍历优化后的 AST 并根据给定的上下文 (Context) 计算结果。

---

## 实现单元详解

为了更好地理解内部逻辑，我们将实现划分为**逻辑单元**和**计算单元**。

### 1. 逻辑单元 (Logical Units)

逻辑单元负责程序的流程控制、条件判断和布尔逻辑。

- **条件分支 (IfExpression)**:
  - 支持 `if <cond> is <result> else is <result>` 模式。
  - 支持 `if <cond> then <action>` 模式（前置条件式）。
  - 支持 `if <cond>` 模式（简单判断，返回布尔值）。
  - 实现逻辑：首先求值 `Condition`，根据其真值 (Truthiness) 决定执行 `Consequence` 还是 `Alternative`。

- **布尔运算 (Boolean Logic)**:
  - **短路与 (&&)**: 实现了短路求值逻辑。如果左侧表达式为假，则立即返回 `false`，不再求值右侧表达式。这对于包含副作用（如赋值）的规则至关重要。

- **比较运算 (Comparisons)**:
  - 支持 `==`, `!=`, `>`, `<`, `>=`, `<=`。
  - 实现逻辑：
    - **整数快径 (Int Fast Path)**: 若双方均为 `int64`，直接比较。
    - **数值提升**: 若存在浮点数，提升为 `float64` 比较。
    - 对于字符串和其他类型，支持相等的判定。

### 2. 计算单元 (Calculation Units)

计算单元负责数据的处理、数值运算和状态变更。

- **算术运算 (Arithmetic)**:
  - 支持 `+`, `-`, `*`, `/`, `%`。
  - **数值双轨制 (Int/Float Separation)**: 内部 `NumberLiteral` 使用 `IsInt` 标志区分 `int64` 和 `float64`。
  - **整数快速路径**: 引擎会识别 `int64` 类型并执行原生整数运算。这避免了将所有数值强制转换为 `float64` 带来的精度损耗和 CPU 转换开销。
  - **字符串拼接**:
    - 基础级：加法运算符作用于双字符串时执行。
    - 高级：`concat` 内置函数，采用 Buffer 池化和长度预计算技术。
  - **数值提升**: 遵循 Go 风格的自动提升规则（如 `int64 + float64 -> float64`）。

- **赋值操作 (Assignment)**:
  - 支持 `<ident> = <expr>`。
  - 赋值表达式不仅会更新上下文中的变量，还会返回被赋予的值。
  - 注意：在 `if...then` 结构中，赋值是常见的副作用操作。

---

## 性能优化实现

Uwasa 引擎针对高并发和高频率调用场景进行了多项优化：

1. **对象池化 (Object Pooling)**:
   - 使用 `sync.Pool` 复用 `Lexer`、`Parser` 和 `MapContext` 实例。
   - 大幅减少了在高并发下的临时内存分配 (Allocations) 和 GC 压力。

2. **分层编译优化层**:
   - **常量折叠 (Fold)**: 针对字面量组成的子树进行递归合并。
   - **逻辑短路优化**: 识别如 `false && expr` 这种在编译阶段即可确定结果的逻辑分支。
   - **再编译器 (Recompiler)**: 进行代数简化（如 `x - x -> 0`）并感知副作用。

3. **高性能 Buffer 池化**:
   - 字符串拼接函数 `concat` 配合 `sync.Pool<bytes.Buffer>`。
   - 执行前计算所有参数总长度，利用 `Buffer.Grow` 一次性申请内存。

4. **类型装箱优化**:
   - 在 Evaluator 中，对常用的布尔返回值（`true`, `false`）使用预分配的 `interface{}` 对象，消除了布尔值装箱带来的开销。

4. **高效优先级解析**:
   - Parser 采用了 Pratt 解析算法，并使用 `switch` 语句优化了运算符优先级的查找过程，相比 Map 查找具有更高的执行效率。

---

## 扩展性设计

- **Context 接口**: 用户可以实现自定义的 `Context`，例如对接 Redis 或数据库，实现动态变量获取。
- **AST 节点**: 引擎的设计允许通过增加新的 Node 类型和对应的解析/求值逻辑来轻松扩展语言特性。
