# Uwasa 引擎设计文档

Uwasa 引擎是一个高性能、专用的规则引擎，旨在处理动态规则求值。它采用了经典的解释器架构，并针对内存和速度进行了深度优化。

## 架构概览

引擎的执行过程分为三个主要阶段：
1. **词法分析 (Lexer)**: 将源代码字符串切分为 Token。
2. **语法分析 (Parser)**: 将 Token 流转换为抽象语法树 (AST)。
3. **解释执行 (Evaluator)**: 遍历 AST 并根据给定的上下文 (Context) 计算结果。

---

## 实现单元详解

为了更好地理解内部逻辑，我们将实现划分为**逻辑单元**和**计算单元**。

### 1. 逻辑单元 (Logical Units)

逻辑单元负责程序的流程控制、条件判断和布尔逻辑。

- **条件分支 (IfExpression)**:
  - 支持 `if <cond> is <result> else is <result>` 模式。
  - 支持 `if <cond> then <action>` 模式（前置条件式）。
  - 支持 `if <cond>` 模式（简单判断，返回布尔值）。
  - 实现逻辑：首先求值 `Condition`，根据其真值 (Truthiness) 决定执行 `Consequence` 还是 `Alternative`。

- **布尔运算 (Boolean Logic)**:
  - **短路与 (&&)**: 实现了短路求值逻辑。如果左侧表达式为假，则立即返回 `false`，不再求值右侧表达式。这对于包含副作用（如赋值）的规则至关重要。

- **比较运算 (Comparisons)**:
  - 支持 `==`, `!=`, `>`, `<`, `>=`, `<=`。
  - 实现逻辑：
    - **整数快径 (Int Fast Path)**: 若双方均为 `int64`，直接比较。
    - **数值提升**: 若存在浮点数，提升为 `float64` 比较。
    - 对于字符串和其他类型，支持相等的判定。

### 2. 计算单元 (Calculation Units)

计算单元负责数据的处理、数值运算和状态变更。

- **算术运算 (Arithmetic)**:
  - 支持 `+`, `-`, `*`, `/`, `%`。
  - **整数快速路径**: 引擎会识别 `int64` 类型并执行原生整数运算，显著降低了 CPU 周期和内存分配。
  - **字符串拼接**: 加法运算符在作用于两个字符串时，执行拼接。
  - **数值提升**: 自动处理 `int64` 与 `float64` 的混合运算，将其提升为 `float64`。

- **赋值操作 (Assignment)**:
  - 支持 `<ident> = <expr>`。
  - 赋值表达式不仅会更新上下文中的变量，还会返回被赋予的值。
  - 注意：在 `if...then` 结构中，赋值是常见的副作用操作。

---

## 性能优化实现

Uwasa 引擎针对高并发和高频率调用场景进行了多项优化：

1. **对象池化 (Object Pooling)**:
   - 使用 `sync.Pool` 复用 `Lexer`、`Parser` 和 `MapContext` 实例。
   - 大幅减少了在高并发下的临时内存分配 (Allocations) 和 GC 压力。

2. **多级编译优化 (Multi-level Optimization)**:
   - **基础层 (OptBasic)**: 实现递归常量折叠与布尔短路优化。
   - **激进层 (OptAggressive)**: 实现代数恒等式简化与静态类型检查。

3. **整数快速路径 (Integer Fast Path)**:
   - 内部数值字面量区分 `int64` 与 `float64`。
   - 对 `int64` 的四则运算和比较不再强制转换为浮点数，减少了计算开销和装箱分配。

4. **类型装箱优化**:
   - 在 Evaluator 中，对常用的布尔返回值（`true`, `false`）使用预分配的 `interface{}` 对象，消除了布尔值装箱带来的开销。

4. **高效优先级解析**:
   - Parser 采用了 Pratt 解析算法，并使用 `switch` 语句优化了运算符优先级的查找过程，相比 Map 查找具有更高的执行效率。

---

## 扩展性设计

- **Context 接口**: 用户可以实现自定义的 `Context`，例如对接 Redis 或数据库，实现动态变量获取。
- **AST 节点**: 引擎的设计允许通过增加新的 Node 类型和对应的解析/求值逻辑来轻松扩展语言特性。
