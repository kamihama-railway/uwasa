# Recompiler (独立再编译器) 深度解析

`Recompiler` 是 Uwasa 引擎中一个可选的高级组件，它在 Parser 产出 AST 后、执行器运行前进行二次编译。其核心目标是通过代数规律精简执行逻辑，并进行严格的静态安全检查。

## 1. 核心行为详述

### 1.1 代数简化 (Algebraic Simplification)
Recompiler 利用数学恒等式对包含变量或常量的表达式进行压缩。即使在变量值未知的情况下，只要其结果是确定的且无副作用，Recompiler 就会将其简化。

| 原始表达式 | 简化结果 | 说明 |
| :--- | :--- | :--- |
| `x + 0` / `0 + x` | `x` | 加法单位元简化 |
| `x - 0` | `x` | 减法单位元简化 |
| `x * 1` / `1 * x` | `x` | 乘法单位元简化 |
| `x * 0` / `0 * x` | `0` | 零乘简化 |
| `x / 1` | `x` | 除法单位元简化 |
| `x - x` | `0` | 恒等消去 (需通过副作用检查) |
| `x == x` | `true` | 恒等比较 (需通过副作用检查) |
| `a = a` | `a` | 冗余自赋值消除 |

### 1.2 增强型静态检查 (Static Analysis)
在编译阶段捕获明显的逻辑错误，避免在生产环境运行时才抛出异常。

- **显式除零检测**: 检测 `1 / 0` 或 `a / 0` 等表达式（只要除数是确定为 0 的字面量）。
- **严格类型匹配**:
    - 禁止对字符串进行 `*`, `/`, `%`, `-` 以及比较运算（如 `>`,`<`）。
    - 禁止字符串与数字混合相加（例如 `"v" + 1` 会报错，建议使用 `concat`）。
    - 逻辑运算一致性：检测 `1 && true` 这种非布尔字面量参与逻辑运算的行为。
- **不可达路径分析**: 如果 `if` 的条件在编译时已被折叠为常量（如 `if true` 或 `if false`），Recompiler 会识别出永远不会执行的分支。

---

## 2. 与外部变量的关系解析

理解 Recompiler 如何处理外部变量是确保规则正确性的关键。

### 2.1 变量的“黑盒”属性
Recompiler 在再编译阶段**不知道**外部变量（Context 中的变量）的具体数值。因此，它不能像 `Fold()` 函数处理字面量那样对 `a + b` 进行求值。

### 2.2 副作用意识 (Side-effect Awareness)
这是 Recompiler 最核心的安全机制。变量可能伴随着状态变更（赋值）。

- **保守策略**: 在进行诸如 `x - x -> 0` 的简化时，Recompiler 会利用内置的 `walk` 递归遍历整棵子树，检测是否包含任何 `AssignExpression`（赋值语句）或函数调用参数中的隐蔽赋值。
- **示例**:
    - `(a + 1) - (a + 1)` -> 简化为 `0`。因为 `a + 1` 只是读取变量，被判定为确定且无副作用。
    - `(a = 10) - (a = 10)` -> **不进行简化**。如果简化为 `0`，则会导致 `a = 10` 这个赋值动作在运行时被跳过，改变了程序语义。

### 2.3 变量引用与优化边界
- **原子性**: Recompiler 将简单的标识符（Identifier）视为原子读取。
- **确定性假设**: Recompiler 假设在单次表达式求值过程中，多次读取同一个标识符的结果是一致的（由规则引擎的单线程顺序执行保证）。基于此，它才能安全地执行 `a == a -> true`。

---

## 3. 性能影响与最佳实践

- **编译开销**: 开启 `UseRecompiler` 会增加 `NewEngine` 的耗时（涉及 AST 的全树递归遍历和分析）。对于需要频繁创建新引擎实例的场景，请权衡。
- **执行收益**: 对于极其复杂的规则，尤其是那些由于模板生成而产生大量 `+ 0` 或 `if true` 冗余结构的规则，Recompiler 能带来显著的运行时性能提升。
- **配置建议**:
    - 开发/调试阶段：**建议开启**，利用其静态检查功能尽早发现规则中的类型错误。
    - 生产稳定阶段：若规则结构简单，使用 `OptBasic` 即可；若规则由外部逻辑动态拼装而成，建议开启以进行结构精简。
