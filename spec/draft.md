# Uwasa Map 实现与语法改进草案 (Second Draft)

## 1. 核心语法改进

### 1.1 原子化方法调用 (Atomic Methods)
Map 操作不再使用冗余的类型标记，而是采用更直观的成员方法调用风格。

| 方法 | 语法示例 | 说明 |
| :--- | :--- | :--- |
| **获取 (get)** | `m.get("key")` | 返回 key 对应的值。若 key 不存在则返回 `nil`。 |
| **存在 (has)** | `m.has("key")` | 返回布尔值 `true` 或 `false`。 |
| **设置 (set)** | `m.set("key", val)` | 设置或更新 key。**不返回值**（或返回 nil）。 |
| **删除 (del)** | `m.del("key")` | 移除指定的 key。**不返回值**。 |

**语法约束：**
- **主体必须是变量**：`.` 操作符左侧必须是一个明确的变量名（Identifier），不支持表达式。
- **禁止链式/嵌套**：不支持 `m.get("a").get("b")` 或 `m.set("a", 1).set("b", 2)`。

### 1.2 序列运算符 `=>`
为了在保持原子性的同时支持连续操作，引入序列运算符。
- **语法**：`Expression_A => Expression_B`
- **执行逻辑**：
  1. 执行左侧表达式 `A`（保留其产生的副作用，如变量赋值或 Map 修改）。
  2. 丢弃 `A` 的返回值。
  3. 执行右侧表达式 `B` 并将其结果作为整个序列的值返回。
- **结合性**：左结合（支持 `A => B => C`）。
- **优先级**：**最低 (LOWEST)**。确保其两侧能捕获完整的逻辑块。

---

## 2. 设计优势

1.  **类型推断简化**：由于限制了 `.` 左侧必须是变量名，编译器可以轻松识别操作目标并生成专用指令（如 `OpMapGet`），无需复杂的运行时类型推导。
2.  **逻辑平铺化**：强制使用 `=>` 运算符替代嵌套调用，使复杂的规则逻辑变得线性、易读。
3.  **零运行开销**：`A => B` 在 VM 层面仅表现为连续的两组指令加上中间的一个 `OpPop`，没有任何额外的跳转或查找开销。

---

## 3. 应用示例

### 场景：根据用户信息动态调整积分
```uwasa
// 1. 获取基础分
score = user.get("score") => 
// 2. 检查 VIP 身份并应用倍率
if user.has("vip") then score = score * 1.5 => 
// 3. 写回更新并记录日志
user.set("score", score) => 
user.set("last_update", "2026-02-22") => 
// 4. 返回最终积分作为规则结果
score
```

---

## 4. 技术实现指南

### 4.1 词法分析 (Lexer)
- 识别 `.` 为 `TokenDot`。
- 识别 `=>` 为 `TokenSequence`。

### 4.2 语法分析 (Parser)
- 为 `.` 注册中缀解析函数，校验左侧是否为 `Identifier`。
- 为 `=>` 注册中缀解析函数，赋予其 `LOWEST` 优先级。

### 4.3 虚拟机 (VM)
- 新增 `OpMapGet`, `OpMapSet`, `OpMapHas`, `OpMapDel` 指令。
- 在 `set` 和 `del` 指令执行后，不向栈中压入任何有效值。
